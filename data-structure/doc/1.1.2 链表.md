# 链表
## Ⅰ. 基本概念

### 1. 既然有数组，为什么要用链表？
* 链表可以更简明地动态管理内存空间占用
* 当需要频繁在表尾之外的位置插入删除数据时，链表更快

### 2. 分类
* 单链表：每个元素中只有一个指针指向直接后继节点
* 双链表：每个元素中有两个指针，分别指向直接前驱节点和直接后继节点
* 循环链表：头尾相接的单、双链表
* 静态链表：用数组描述的链表，(C的实现一般是结构体数组)

### 3. 基本结构
* 头指针`*head`：指向链表的头元素$a_1$
* 对于元素$a_i$，包含指针`*next`：指向它的后继元素$a_{i+1}$

## Ⅱ. 单链表

### 1. 操作效率计算
设链表长为$n$,单链表每次访问、查找元素必须从表头开始，如果查找任一元素的概率相等，则有$p_i=\frac{1}{n}$,平均查找长度$E$为：$$E=\frac{1}{n}\sum^n_{i=1}i=\frac{n+1}{2}$$
即最好情况查找一次(表头)，最坏情况查找$n$次(表尾)，平均为$\frac{n+1}{2}$。

即单链表查找平均时间复杂度为$O(n)$
最好情况下时间复杂度为$O(1)$(表头)
最坏情况下时间复杂度为$O(n)$(表尾)

而对于链表来说，插入和删除元素只需要查找对应位置后进行常数次操作即可完成，所以插入与删除操作的时间复杂度同上。
	
*注：对于链表来说，查找只能遍历。但是对于顺序表来说，有序表和无序表的查找速度并不相同。仅就访问单个特定元素来说，顺序表的效率是比链表高的。*

### 2. 循环单链表
对于循环链表来说，效率与非循环链表并无本质区别。


## Ⅲ. 双链表
### 1. 意义：
对与相对较长的单链表，对于节点的检索只能是从表头向后进行单向的遍历。但是如果在节点中再添加一个指向前趋节点的指针，则遍历就可以双向进行，提高效率。

## Ⅳ. 对称链表
### 1. 原理
异或运算有下列性质：$$(X\oplus Y)\oplus X=Y\\(X\oplus Y)\oplus Y=X\\X \oplus 0=X$$
利用该性质，对于节点$K_i$的指针域，存储$K_{i-1}$和$K_{i+1}$的地址的异或运算值$(A_{i-1}\oplus A_{i+1})$，那么显然有$$(A_{i-1}\oplus A_{i+1})A_{i-1} =A_{i+1}\\(A_{i-1}\oplus A_{i+1})A_{i+1} =A_{i-1}$$即可以使用一个指针同时存储前后节点的地址，省下一个指针的存储空间。

## Ⅴ. 十字链表
### 1. 稀疏矩阵的表示
对于稀疏矩阵，可以使用三元组进行压缩存储。即对于一个有着$t$个非零元素的$m\times n$稀疏矩阵，可以用数组$M[t+1][3]$进行表示。其中子数组$M[0]=\{m,n,t\}$,其中对于非零元素$a_{ij}$，以子数组$M[x]=\{i,j,a_{ij}\}$的形式存储。(各元素的相对顺序可以是随机的)

显然，对于适合使用三元组压缩的矩阵，满足$m*n\gg3t$。

使用三元组表示稀疏矩阵只对转置运算友好，难以进行四则运算

### 2. 十字链表
十字链表是稀疏矩阵的一种存储方法，其中稀疏矩阵的每一个非零元素是表中的一个节点（准确来说是内部节点），存储着元素的行、列和元素值本身。节点含有两个指针域，**右指针**指向本行的下一个非零元素节点，**下指针**指向本列的下一个非零元素节点。
<div align=center><img src=../asset/十字链表.png></div>

对于上图，节点$H_0\sim H_4$为外部节点，其中$H_0$中存储矩阵的大小信息。矩阵的每一行和每一列的第一个节点都是外部节点，所以$H_1\sim H_4$的右、下指针是其对应行/列链表的头指针，而$H_0$可以看作是整个矩阵的头。

可以发现，由于编程语言的要求，外部节点和内部节点的结构并不能完全相同。若将两种节点的结构分别定义，会对程序设计造成一定困难，对于该问题，共有两种解决方法。

### 3. 十字链表的节点实现
1. 辅助向量
    对于$m\times n$矩阵$A$所对应的十字链表，定义一个向量$cp[M]$，满足$$M=max(m,n)$$
    即`struct node cp[M];`
    $cp[0]$即是节点$H_0$，$cp[i](i=1,2,...,M)$即是节点$H_1\sim H_M$，向量中的前后顺序关系完成了链接表头的目的（即图中的虚线关系），也令链表中的节点达成了同构。
2. 共同体定义
    可以将节点中的数据定义成共同体，使得其能够同时存储元素值和指向节点的指针，即：
    ``` c
    struct node {
        int col, row;
        union {
            float val;
            struct node* next;
        }x;
        struct node *down, *right;
    }
    
    ```