# 队列
## 1. 定义
**队列**(queue)是一个线性表，其插入和删除分别在表的不同端进行。插入元素的端叫**队尾**(back/rear)，删除元素的端叫**队首**(front)。
即队列是一个**先进先出**(FIFO)的线性表

## 2. ADT
    ADT queue
    {
        实例
            线性表；一端称为队首，另一端称为队尾
        操作
            empty()：如果队列为空则返回ture，否则返回false
            size()：返回队列中元素个数
            front()：返回队列头元素
            back()：返回队列尾元素
            pop()：删除队列首元素
            push(x)：把x加入队列尾
    }

## 3. 实现形式
* 顺序存储结构
	如果采用映射方式：$$location(i)=i$$
    该映射方式在创建线性表和栈是很有效，但是对于队列来说，在数组首位插入和删除元素的TC是$O(n)$的，开销相对较大。<br>
    如果对空间要求不高，更好的方法是只移动队首位置而不去移动元素，即使用映射方式：$$location(i)=location(队首元素)+i$$
    但是这种映射会出现情况：队列元素个数小于数组大小，但是队尾却已经没有剩余的空间（即队列被移到了数组的最右端），此时就需要将队列整体左移，移动的TC为$O(n)$。这样看来，其实是变相的以降低插入速度的带价换取删除速度的提升。
    <br>
    我们还可以将队列视作一个环，使用映射：$$location(i)=(location(队首元素)+i)\%arrayLenth$$
    注意，除去队列初始为空的状态以外，指针 front、rear 不能重叠。否则，初始队空与当前队满的状态无法分别。所以，一般说队列头指针与队列尾指针需要间隔一个空单元，即实际队列大小为arrayLenth-1。
    <div align=center><img src=../asset/循环队列.png></div>
* 链式存储结构
    略